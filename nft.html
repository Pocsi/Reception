<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>NFT View</title>
  
  <!-- Open Graph / Facebook -->
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://pocsi.github.io/Reception/nft.html">
  <meta property="og:title" content="NFT View">
  <meta property="og:description" content="Interactive NFT display">
  <meta property="og:image" content="https://pocsi.github.io/Reception/nft.gif">

  <!-- Twitter -->
  <meta property="twitter:card" content="summary_large_image">
  <meta property="twitter:url" content="https://pocsi.github.io/Reception/nft.html">
  <meta property="twitter:title" content="NFT View">
  <meta property="twitter:description" content="Interactive NFT display">
  <meta property="twitter:image" content="https://pocsi.github.io/Reception/nft.gif">

  <!-- Web3.js -->
  <script src="https://cdn.jsdelivr.net/npm/web3@1.5.2/dist/web3.min.js"></script>
  <!-- Chainlink Price Feeds ABI -->
  <script src="https://cdn.jsdelivr.net/npm/@chainlink/contracts@0.4.0/abi/v0.8/AggregatorV3Interface.json"></script>

  <style>
    body {
      margin: 0;
      padding: 0;
      background-color: #ffffff;
      font-family: Arial, sans-serif;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      overflow: hidden;
    }

    .nft-container {
      position: relative;
      width: 100%;
      height: calc(100vh - 60px);
      display: flex;
      justify-content: center;
      align-items: center;
      overflow: hidden;
    }

    .nft-image {
      max-width: 5%;
      max-height: 5vh;
      object-fit: contain;
      transition: transform 0.1s ease-out;
    }

    .crypto-carousel {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 60px;
      background-color: #f8f9fa;
      border-top: 1px solid #e9ecef;
      overflow: hidden;
      z-index: 1000;
    }

    .crypto-track {
      display: flex;
      animation: scroll 30s linear infinite;
      white-space: nowrap;
    }

    .crypto-item {
      display: inline-flex;
      align-items: center;
      padding: 0 20px;
      color: #212529;
      font-size: 14px;
    }

    .crypto-item.positive {
      color: #28a745;
    }

    .crypto-item.negative {
      color: #dc3545;
    }

    .update-time {
      position: fixed;
      bottom: 5px;
      right: 5px;
      font-size: 12px;
      color: #6c757d;
      z-index: 1001;
    }

    @keyframes scroll {
      0% {
        transform: translateX(0);
      }
      100% {
        transform: translateX(-50%);
      }
    }
  </style>
</head>
<body>
  <div class="nft-container">
    <img src="nft.gif" alt="NFT" class="nft-image" id="nftImage">
  </div>

  <div class="crypto-carousel">
    <div class="crypto-track" id="cryptoTrack">
      <!-- Los elementos se agregarán dinámicamente -->
    </div>
  </div>
  <div class="update-time" id="updateTime"></div>

  <script>
    // Configuración de Web3 y contratos
    const web3 = new Web3(window.ethereum || 'https://mainnet.infura.io/v3/TU_INFURA_KEY');
    
    // Direcciones de los contratos Chainlink Price Feeds
    const PRICE_FEEDS = {
      'AAPL': '0x73A3919a69eFCd5b19df8348c6740bB1446b5e91',
      'MSFT': '0x73A3919a69eFCd5b19df8348c6740bB1446b5e91',
      'GOOGL': '0x73A3919a69eFCd5b19df8348c6740bB1446b5e91',
      // ... más direcciones de Price Feeds
    };

    // Direcciones de los contratos de datos ESG
    const ESG_CONTRACTS = {
      'AAPL': '0x...', // Dirección del contrato ESG
      'MSFT': '0x...',
      'GOOGL': '0x...',
      // ... más direcciones de contratos ESG
    };

    // ABI para los contratos
    const PRICE_FEED_ABI = [
      {
        "inputs": [],
        "name": "latestRoundData",
        "outputs": [
          {
            "internalType": "uint80",
            "name": "roundId",
            "type": "uint80"
          },
          {
            "internalType": "int256",
            "name": "answer",
            "type": "int256"
          },
          {
            "internalType": "uint256",
            "name": "startedAt",
            "type": "uint256"
          },
          {
            "internalType": "uint256",
            "name": "updatedAt",
            "type": "uint256"
          },
          {
            "internalType": "uint80",
            "name": "answeredInRound",
            "type": "uint80"
          }
        ],
        "stateMutability": "view",
        "type": "function"
      }
    ];

    const ESG_ABI = [
      {
        "inputs": [],
        "name": "getESGScore",
        "outputs": [
          {
            "internalType": "uint256",
            "name": "",
            "type": "uint256"
          }
        ],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [],
        "name": "getSustainabilityMetrics",
        "outputs": [
          {
            "internalType": "string",
            "name": "impact",
            "type": "string"
          },
          {
            "internalType": "string",
            "name": "website",
            "type": "string"
          }
        ],
        "stateMutability": "view",
        "type": "function"
      }
    ];

    // Lista de los 35 activos más sostenibles
    let sustainableAssets = [];

    // Función para cargar la lista de activos desde un archivo JSON
    async function loadSustainableAssets() {
      try {
        const response = await fetch('sustainable_assets.json');
        if (!response.ok) {
          throw new Error('No se pudo cargar la lista de activos');
        }
        const data = await response.json();
        sustainableAssets = data;
        await updateCarousel();
      } catch (error) {
        console.error('Error al cargar la lista de activos:', error);
        // Si hay error, usar la lista por defecto
        sustainableAssets = [
          { symbol: 'BEN', name: 'Ben & Jerry\'s', impact: 'B Corp, Fair Trade', website: 'https://www.benjerry.com' },
          // ... resto de la lista por defecto ...
        ];
      }
    }

    // Función para verificar si un enlace es válido
    async function checkLink(url) {
      try {
        const response = await fetch(url, { method: 'HEAD', mode: 'no-cors' });
        return true;
      } catch (error) {
        return false;
      }
    }

    // Función para agregar un nuevo activo
    async function addNewAsset(asset) {
      try {
        // Verificar que el enlace sea válido
        const isLinkValid = await checkLink(asset.website);
        if (!isLinkValid) {
          throw new Error('El enlace proporcionado no es válido');
        }

        // Verificar que el símbolo no exista
        if (sustainableAssets.some(a => a.symbol === asset.symbol)) {
          throw new Error('El símbolo ya existe en la lista');
        }

        // Agregar el nuevo activo
        sustainableAssets.push(asset);
        
        // Actualizar el carrusel
        await updateCarousel();
        
        // Guardar la lista actualizada
        await saveSustainableAssets();
        
        return true;
      } catch (error) {
        console.error('Error al agregar nuevo activo:', error);
        return false;
      }
    }

    // Función para eliminar un activo
    async function removeAsset(symbol) {
      try {
        sustainableAssets = sustainableAssets.filter(asset => asset.symbol !== symbol);
        await updateCarousel();
        await saveSustainableAssets();
        return true;
      } catch (error) {
        console.error('Error al eliminar activo:', error);
        return false;
      }
    }

    // Función para guardar la lista actualizada
    async function saveSustainableAssets() {
      try {
        const response = await fetch('sustainable_assets.json', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(sustainableAssets)
        });
        
        if (!response.ok) {
          throw new Error('No se pudo guardar la lista de activos');
        }
      } catch (error) {
        console.error('Error al guardar la lista de activos:', error);
      }
    }

    // Función para obtener datos de precios desde Chainlink
    async function getPriceData(symbol) {
      try {
        if (!PRICE_FEEDS[symbol]) {
          throw new Error(`No price feed for ${symbol}`);
        }

        const contract = new web3.eth.Contract(PRICE_FEED_ABI, PRICE_FEEDS[symbol]);
        const data = await contract.methods.latestRoundData().call();
        
        // Obtener precio actual y precio de hace 24 horas
        const currentPrice = data.answer / 1e8;
        const historicalData = await contract.methods.getRoundData(data.roundId - 1440).call(); // 1440 rounds = 24 hours
        const historicalPrice = historicalData.answer / 1e8;
        
        // Calcular el porcentaje de cambio
        const priceChange = ((currentPrice - historicalPrice) / historicalPrice) * 100;
        
        return {
          price: currentPrice.toFixed(2),
          priceChange: priceChange.toFixed(2),
          timestamp: new Date(data.updatedAt * 1000).toLocaleTimeString()
        };
      } catch (error) {
        console.error(`Error fetching price for ${symbol}:`, error);
        return null;
      }
    }

    // Función para obtener datos ESG desde el contrato
    async function getSustainabilityData(symbol) {
      try {
        if (!ESG_CONTRACTS[symbol]) {
          throw new Error(`No ESG contract for ${symbol}`);
        }

        const contract = new web3.eth.Contract(ESG_ABI, ESG_CONTRACTS[symbol]);
        const esgScore = await contract.methods.getESGScore().call();
        
        return {
          esgScore: (esgScore / 100).toFixed(1),
          timestamp: new Date().toLocaleTimeString()
        };
      } catch (error) {
        console.error(`Error fetching ESG data for ${symbol}:`, error);
        return null;
      }
    }

    // Función para obtener datos de sostenibilidad desde el oráculo ESG
    async function getSustainabilityMetrics(symbol) {
      try {
        if (!ESG_CONTRACTS[symbol]) {
          throw new Error(`No ESG contract for ${symbol}`);
        }

        const contract = new web3.eth.Contract(ESG_ABI, ESG_CONTRACTS[symbol]);
        const metrics = await contract.methods.getSustainabilityMetrics().call();
        
        return {
          impact: metrics.impact,
          website: metrics.website,
          timestamp: new Date().toLocaleTimeString()
        };
      } catch (error) {
        console.error(`Error fetching sustainability metrics for ${symbol}:`, error);
        return null;
      }
    }

    // Función para descubrir nuevos activos sostenibles
    async function discoverNewAssets() {
      try {
        // Consultar el oráculo ESG para obtener nuevos activos
        const response = await fetch('https://api.sustainability-oracle.com/v1/assets', {
          method: 'GET',
          headers: {
            'Content-Type': 'application/json'
          }
        });

        if (!response.ok) {
          throw new Error('No se pudieron obtener nuevos activos');
        }

        const newAssets = await response.json();
        
        // Procesar cada nuevo activo
        for (const asset of newAssets) {
          // Verificar si el activo ya existe
          if (!sustainableAssets.some(a => a.symbol === asset.symbol)) {
            // Obtener métricas de sostenibilidad
            const metrics = await getSustainabilityMetrics(asset.symbol);
            
            if (metrics) {
              // Verificar que el enlace sea válido
              const isLinkValid = await checkLink(metrics.website);
              
              if (isLinkValid) {
                // Agregar el nuevo activo
                await addNewAsset({
                  symbol: asset.symbol,
                  name: asset.name,
                  impact: metrics.impact,
                  website: metrics.website
                });
              }
            }
          }
        }
      } catch (error) {
        console.error('Error al descubrir nuevos activos:', error);
      }
    }

    // Función para actualizar el carrusel
    async function updateCarousel() {
      const track = document.getElementById('cryptoTrack');
      track.innerHTML = '';

      for (const asset of sustainableAssets) {
        const priceData = await getPriceData(asset.symbol);
        const sustainabilityData = await getSustainabilityData(asset.symbol);
        const metrics = await getSustainabilityMetrics(asset.symbol);
        const isLinkValid = await checkLink(asset.website);

        if (priceData && sustainabilityData && metrics && isLinkValid) {
          const item = document.createElement('div');
          item.className = 'crypto-item';
          
          // Crear el enlace
          const link = document.createElement('a');
          link.href = asset.website;
          link.target = '_blank';
          link.rel = 'noopener noreferrer';
          link.style.textDecoration = 'none';
          link.style.color = 'inherit';
          
          // Determinar el color del cambio de precio
          const priceChangeColor = priceData.priceChange >= 0 ? '#28a745' : '#dc3545';
          
          link.innerHTML = `
            ${asset.symbol} $${priceData.price}
            <span style="font-size: 12px; color: ${priceChangeColor}; margin-left: 5px;">
              ${priceData.priceChange >= 0 ? '+' : ''}${priceData.priceChange}%
            </span>
            <span style="font-size: 12px; color: #6c757d; margin-left: 5px;">
              ESG: ${sustainabilityData.esgScore}
            </span>
            <span style="font-size: 10px; color: #6c757d; margin-left: 5px;">
              ${metrics.impact}
            </span>
            <span style="font-size: 10px; color: #6c757d; margin-left: 5px;">
              (${priceData.timestamp})
            </span>
          `;
          
          item.appendChild(link);
          track.appendChild(item);
        }
      }

      const updateTime = document.getElementById('updateTime');
      updateTime.textContent = `Última actualización: ${new Date().toLocaleTimeString()}`;
    }

    // Cargar la lista inicial y actualizar cada 24 horas
    loadSustainableAssets();
    setInterval(updateCarousel, 24 * 60 * 60 * 1000);
    // Descubrir nuevos activos cada 24 horas
    setInterval(discoverNewAssets, 24 * 60 * 60 * 1000);

    // Código existente para el zoom de la imagen
    const image = document.getElementById('nftImage');
    let scale = 1;
    const zoomFactor = 0.1;

    window.addEventListener('wheel', (e) => {
      e.preventDefault();
      
      if (e.deltaY < 0) {
        scale = Math.min(scale + zoomFactor, 2);
      } else {
        scale = Math.max(scale - zoomFactor, 0.5);
      }
      
      image.style.transform = `scale(${scale})`;
    }, { passive: false });
  </script>
</body>
</html> 